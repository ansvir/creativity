package logic.language.editor.font.builder;

import name.suchanek.doubletype.TTCodePage;
import java.io.RandomAccessFile;
import java.io.File;
import name.suchanek.doubletype.TTGlyph;
import name.suchanek.doubletype.TTUnicodeRange;
import name.suchanek.doubletype.FontFileWriter;

public class Svg2Ttf
{
    public static final int scale = 2;
    
    protected static boolean addGlyph(final char c, final SvgFont svgFont, final FontFileWriter writer) {
        if (c == ' ') {
            return false;
        }
        final TTUnicodeRange range = TTUnicodeRange.of(c);
        if (range != null) {
            writer.addUnicodeRange(range);
        }
        final TTGlyph glyph = GlyphCreator.makeGlyph(c, svgFont);
        if (glyph == null) {
            return false;
        }
        final int index = writer.addGlyph(glyph);
        writer.addCharacterMapping(c, index);
        return true;
    }
    
    public static byte[] convert(final File fol, final String designer, final String designerUrl) throws Exception {
        System.out.println("Converting " + fol.getCanonicalPath());
        final SvgFont svgFont = new SvgFont(fol);
        Throwable t = null;
        try {
            final RandomAccessFile out = new RandomAccessFile(fol.toString().replaceAll(".svg$", ".ttf"), "rw");
            try {
                final FontFileWriter writer = new FontFileWriter(out);
                writer.setAscent((int)(svgFont.getAscent() * 2.0));
                writer.setDescent((int)(svgFont.getDescent() * -2.0));
                writer.setLineGap(0);
                writer.setOffset(0);
                writer.setXHeight((int)(svgFont.getAscent() * 8.0 / 10.0 * 2.0));
                writer.setCodeRangeFlag(TTCodePage.forName("US-ASCII").getOsTwoFlag());
                writer.setCodeRangeFlag(TTCodePage.forName("windows-1252").getOsTwoFlag());
                writer.setCodeRangeFlag(TTCodePage.forName("windows-1251").getOsTwoFlag());
                writer.setNames(svgFont.getName(), designer, designerUrl);
                writer.addCharacterMapping(1L, writer.addGlyph(DefaultGlyphs.undef()));
                writer.addCharacterMapping(0L, writer.addGlyph(DefaultGlyphs.nullGlyph()));
                TTGlyph space = GlyphCreator.makeGlyph(' ', svgFont);
                if (space == null) {
                    space = DefaultGlyphs.spaceGlyph();
                }
                writer.addCharacterMapping(13L, writer.addGlyph(space));
                writer.addCharacterMapping(32L, writer.addGlyph(space));
                for (char c = ' '; c < '\u0080'; ++c) {
                    addGlyph(c, svgFont, writer);
                }
                for (final char c : svgFont.characters()) {
                    if (c >= ' ' && c < '\u0080') {
                        continue;
                    }
                    addGlyph(c, svgFont, writer);
                }
                for (final char c2 : svgFont.kernings()) {
                    for (final char c3 : svgFont.kerningsOf(c2)) {
                        writer.addKern(c2, c3, svgFont.kerning(c2, c3).intValue() * -2);
                    }
                }
                byte[] document = writer.toByteArray();
                System.out.println("done");
                return document;

            }
            finally {
                if (out != null) {
                    out.close();
                }
            }
        }
        finally {
            {
                final Throwable exception = new Throwable();
                t = exception;
            }
        }

    }
    
    public static void main(final String[] args) throws Exception {
        if (args == null || args.length != 3) {
            System.out.println("Converts an SVG font file generated by PowerLine to TTF\n");
            System.out.println("Call: Svg2ttf file.svg designerName designerUrl");
            System.exit(63);
        }
        convert(new File(args[0]), args[1], args[2]);
    }
}
